
== Conhecendo o CQL

A comunicação com o banco de dados seja para a criação de tabelas, manipulação de dados é
certamente a coisa mais trivial num banco de dados, seja relacional, seja não relacional.
O Cassandra oferece sua própria linguagem para comunicação com o banco de dados,
o Cassandra Query language ou CQL. O CQL oferece uma linguagem próximo ao SQL, porém, de maneira mais simples uma vez que, por exemplo, não existe os conceitos de joins
(inner join, left join, dentre outros) dentro das buscas do Cassandra. Um desenvolvedor que já conheça o SQL terá uma curva de aprendizagem muito menor para aprender essa linguagem do Cassandra.
Esse capítulo terá o objetivo de falar um pouco sobre essa linguagem.

TIP: Para essas operações utilizaremos o client cqlsh que explicamos o seu acesso no capítulo anterior.

=== Keyspace

A nossa primeira parada no CQL é a criação da maior estrutura dentro da hierarquia do Cassandra, sim o keyspace. É durante a criação do keyspace que é definido a estratégia de replicação e o fator de réplica para os dados. O template da criação é mostrado a seguir:

[source,sql]
----
create_keyspace_statement ::=  CREATE KEYSPACE [ IF NOT EXISTS ] keyspace_name WITH options
----

Por exemplo, ao se criar um keyspace de livraria:

[source,sql]
----
CREATE KEYSPACE library  WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
//or
CREATE KEYSPACE library
           WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1' : 1, 'DC2' : 3}
            AND durable_writes = false;
----

Realizado a criação do novo keyspace é possível verificar os keyspaces criados no Cassandra para isso realizaremos a nossa primeira query. `select * from system_schema.keyspaces;` é possível perceber a semelhança com o banco de dados relacional. Falaremos mais sobre buscar informações nos itens a seguir.

.Resultado simplicado da busca pelo keyspace 'library'
[source,sql]
----
cqlsh> select * from system_schema.keyspaces where keyspace_name= 'library';

 keyspace_name |replication
---------------+------------------------------------------------------
       library |{'class': 'SimpleStrategy', 'replication_factor': '3'}

(1 rows)
----

Uma vez criado o keyspace é possível realizar alguma alteração do mesmo, para isso é necessário utilizar o *alter keyspace*. O template é mostrado a seguir:

[source,sql]
----
alter_keyspace_statement ::=  ALTER KEYSPACE keyspace_name WITH options
----

Por exemplo, alterando o keyspace library:

[source,sql]
----
ALTER KEYSPACE Excelsior WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 4};
----

Também é possível remover o keyspace com o *drop keyspace*, no nosso exemplo:

[source,sql]
----
DROP KEYSPACE library;
----

O que acontece caso se remova ou se crie duas vezes o mesmo keyspace?
Caso o usuário tenta criar ou remover mais de uma vez a mesma tabela, uma mensagem de erro é gerada. Por exemplo, `Keyspace 'library' already exists` ou `ConfigurationException: Cannot drop non existing keyspace 'library'.` para criar ou remover respectivamente. Uma maneira de evitar tal erro é realizar essa alteração caso realmente faça sentido, por exemplo, só crie caso ela não exista ou só remova caso ela exista. Com esse objetivo a sintaxe suporta essa condição, usando o mesmo exemplo de livraria executando o a criação e a remoção de maneira segura.


[source,sql]
----
DROP KEYSPACE IF EXISTS library;
CREATE KEYSPACE IF NOT EXISTS library  WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
----

=== Familia de Colunas

A criação da família de coluna de maneira análoga é semelhante a criação da tabela é nela que são definidos os campos, partition key, clustering key, o índice, e mais configurações, para isso basta utilizar o template `CREATE TABLE`:


[source,sql]
----
create_table_statement ::=  CREATE TABLE [ IF NOT EXISTS ] table_name
                            '('
                                column_definition
                                ( ',' column_definition )*
                                [ ',' PRIMARY KEY '(' primary_key ')' ]
                            ')' [ WITH table_options ]
column_definition      ::=  column_name cql_type [ STATIC ] [ PRIMARY KEY]
primary_key            ::=  partition_key [ ',' clustering_columns ]
partition_key          ::=  column_name
                            | '(' column_name ( ',' column_name )* ')'
clustering_columns     ::=  column_name ( ',' column_name )*
table_options          ::=  COMPACT STORAGE [ AND table_options ]
                            | CLUSTERING ORDER BY '(' clustering_order ')' [ AND table_options ]
                            | options
clustering_order       ::=  column_name (ASC | DESC) ( ',' column_name (ASC | DESC) )*
----

Por exemplo, dado que foi criado o keyspace library o próximo passo é criar a família de coluna de livros:

.A simples criação de uma família de coluna de livros do qual temos o nome como a chave (que deve ser única e, atualmente, é a única forma de buscar o livro).
[source,sql]
----
CREATE TABLE library.book (
    name text PRIMARY KEY,
       year int
);
----

TIP: É possível também verificar a família de coluna existe antes de criar, utilizando o `IF NOT EXISTS` semelhante ao keyspace.

Também é possível realizar alterações na família de coluna, por exemplo, adicionar ou remover um campo dentro da família de coluna. Para isso, é necessário utilizar o seguinte template:

[source,sql]
----
alter_table_statement   ::=  ALTER TABLE table_name alter_table_instruction
alter_table_instruction ::=  ADD column_name cql_type ( ',' column_name cql_type )*
                             | DROP column_name ( column_name )*
                             | WITH options
----

Por exemplo, adicionar o campo autor:

[source,sql]
----
ALTER TABLE library.book ADD author text;
----

Caso queria remover o mesmo campo:

[source,sql]
----
ALTER TABLE library.book DROP author;
----

Também é possível destruir a estrutura recém-criada.

[source,sql]
----
drop_table_statement ::=  DROP TABLE [ IF EXISTS ] table_name
----

No nosso exemplo:

[source,sql]
----
DROP TABLE IF EXISTS library.book;
----

Existem caso que o objetivo não distruir a estrutura, mas remover todo o conteúdo e manter a estrutura, para isso, é possível truncar a família de coluna. Para isso, existe o comando `TRUNCATE`.

[source,sql]
----
truncate_statement ::=  TRUNCATE [ TABLE ] table_name
----


Por exemplo, ao se criar novamente a família de coluna e adicionamos alguns livros, em seguida, truncamos a tabela e verificamos o resultado.


.Criação da tabela `book` e a inserção de dois livros
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.book (
    name text PRIMARY KEY,
       year int
);
INSERT INTO library.book  JSON '{"name": "Effective Java", "year": 2001}';
INSERT INTO library.book  JSON '{"name": "Clean Code", "year": 2008}';
----

.Executando a query para buscar o resultado
[source,sql]
----
cqlsh> SELECT * FROM library.book;

 name           | year
----------------+------
     Clean Code | 2008
 Effective Java | 2001

(2 rows)
----

[source,sql]
----
TRUNCATE library.book;
----

.Executando a query para buscar o resultado
[source,sql]
----
cqlsh> SELECT * FROM library.book;

 name | year
------+------

(0 rows)

----

==== Chave primária

Dentro da família de coluna a chave primária, primary key, é o campo único e todas as famílias de colunas *devem* defini-la. É a partir desse campo que o os dados serão recuperados, por issso, existe uma preocupação inicial com esse campo. A chave primária pode ser constituída por mais de um campo, porém, ela terá um conceito diferente do banco relacional. Ele será dividida em duas partes:

* The *partition key*: É a primeira parte da chave primária. É nesse campo que será definido o hash onde será definido onde os dados serão enviados. Ou seja, valores com o mesmo parition key tendem a ser enviados para os mesmos clusters e é ele que definirá como os dados serão distribuídos através dos clusters.
* O *clustering columns*: Essa chave tem o poder de definir a ordem dentro da tabela, por exemplo, ao criar uma família de autores definimos o nome como chave e seus livros como ordem.


[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    PRIMARY KEY (name, book)
);
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Agile Principles, Patterns", "year": 2006}';
----

Ao executar a query teremos o seguinte resultado:

[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book                       | year
---------------------+----------------------------+------
 Robert Cecil Martin | Agile Principles, Patterns | 2006
 Robert Cecil Martin |         Clean Architecture | 2017
 Robert Cecil Martin |                 Clean Code | 2008

(3 rows)
----

Uma outra opção é, remover a tabela e criar novamente, dessa vez com a ordem dos livros de maneira decrescente. Assim:

[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    PRIMARY KEY (name, book)
)
WITH CLUSTERING ORDER BY (book DESC);

INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Agile Principles, Patterns", "year": 2006}';
----


[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book                       | year
---------------------+----------------------------+------
 Robert Cecil Martin |                 Clean Code | 2008
 Robert Cecil Martin |         Clean Architecture | 2017
 Robert Cecil Martin | Agile Principles, Patterns | 2006

(3 rows)

----
Apenas recapitulando, dentre outros objetivos é a partir da chave é possível realizar a busca das informações, por exemplo, utilizando nossa pequena estrutura de dados de autores:


.Realizando a busca a partir da chave, nome do autor do livro.
[source,sql]
----
cqlsh> SELECT book FROM library.author WHERE name = 'Robert Cecil Martin';

 book
----------------------------
                 Clean Code
         Clean Architecture
 Agile Principles, Patterns

(3 rows)
----

Caso seja necessário realizar a busca por um campo que não seja a chave, partition key, isso não será possível. Assim, no nosso exemplo, tanto a busca pelo livro e pelo ano dará a mesma mensagem de erro.

.Ao tentar executar a query é retornado um erro, não é possível ler da família de coluna de forma eficiente.
[source,sql]
----
cqlsh> SELECT * FROM library.author WHERE year =2017;
InvalidRequest: Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"
cqlsh> SELECT * FROM library.author WHERE book  ='Clean Architecture';
InvalidRequest: Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"
----

Como mostra a mensagem de erro, a única maneira de executar a query é adicionando o comando `ALLOW FILTERING`, porém, isso terá sérias consequências de performance.

[source,sql]
----
cqlsh> SELECT * FROM library.author WHERE year =2017 ALLOW FILTERING;
 name                | book               | year
---------------------+--------------------+------
 Robert Cecil Martin | Clean Architecture | 2017
(1 rows)

cqlsh> SELECT * FROM library.author WHERE book  ='Clean Architecture' ALLOW FILTERING;
name                | book               | year
---------------------+--------------------+------
 Robert Cecil Martin | Clean Architecture | 2017

(1 rows)
----

A maneira da qual o cassandra executa esse comando é recuperando todas as linhas e então filtrando por aqueles que não tem o valor da condição. Por exemplo, uma família de colunas que tenha um milhão de linhas e 98% tenha a condição da query, isso será relativamente eficiente. Porém, imagine o caso de que apenas uma linha atenda a condição, ou seja, o Cassandra percorreu de maneira linear e ineficiente 999999 elementos para apenas retornar um.

WARNING: Se uma query é rejeitada pelo Cassandra pedindo o filtro, resita ao uso do `ALLOW FILTERING`. Verifique sua modelagem, seus dados e volumetria e verifique o que você realmente quer fazer.

TIP: Uma segunda opção é o uso de índices secundários que será abordado a seguir.

==== Tipos estáticos

Algumas colunas podem ser consideradas estáticas dentro da família de coluna. Uma coluna estática é uma coluna que compartilha o mesmo valor para todas as linhas que tenham o mesmo valor de partition key. Por exemplo, imagine o cenário de família de coluna autor (com nome e livro), e agora existe o desejo de se adicionar o campo país de residência. Uma vez que o autor mude de país é importante que todas as suas referências também sejam atualizadas, assim, criaremos o campo país como estático, exibido a seguir:


.Criando a estrutura de `author` agora com o campo estático país
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    country text static,
    PRIMARY KEY (name, book)
);
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "country": "USA", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Joshua Bloch", "book": "Effecive Java", "year": 2001}';
INSERT INTO library.author  JSON '{"name": "Joshua Bloch", "book": "JAVA PUZZLERS", "year": 2005, "country": "Brazil"}';
----

.Mesmo inserido uma única vez, ele foi persistido em todos os campos com a mesma chave.
[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book               | country | year
---------------------+--------------------+---------+------
        Joshua Bloch |      Effecive Java |  Brazil | 2001
        Joshua Bloch |      JAVA PUZZLERS |  Brazil | 2005
 Robert Cecil Martin | Clean Architecture |     USA | 2017
 Robert Cecil Martin |         Clean Code |     USA | 2008

(4 rows)

----


==== Índice secundário


Existe uma outra opção para buscar as informações da tabela além da chave primária, que é o índice secundário. Ele permite a busca de informação sem que gera o erro do `ALLOW FILTERING` o seu template é exibido a seguir:

[source,sql]
----
index_name ::=  re('[a-zA-Z_0-9]+')
----

Por exemplo, realizar uma busca pelo campo ano na família de coluna de autores é possível com a criação de um índice secundário:


[source,sql]
----
index_name ::=  re('[a-zA-Z_0-9]+')
----

Por exemplo, realizar uma busca pelo campo ano na família de coluna de autores é possível executar o seguinte comando:

[source,sql]
----
CREATE INDEX year_index ON library.author (year);
----

Assim, finalmente é possível executar a query a partir do ano:

[source,sql]
----
cqlsh> SELECT * FROM library.author where year = 2005;

 name         | book          | country | year
--------------+---------------+---------+------
 Joshua Bloch | JAVA PUZZLERS |  Brazil | 2005

(1 rows)
----

Também é possível remover o índice criado com o DROP INDEX:

[source,sql]
----
drop_index_statement ::=  DROP INDEX [ IF EXISTS ] index_name
----

No nosso exemplo:

[source,sql]
----
DROP  INDEX IF EXISTS library.year_index;
----


==== Como funciona o índice secundário

Os índices secundários são criados para uma coluna dentro de uma família de coluna. Esses índices são armazenados localmente para cada nó e é criado em backgroug. If uma query baseada em índice secundário é utilizado, ou seja, não é restrito pela chave, dessa maneira aumentará a latência uma vez que não limitado pela chave e todos os nós serão consultados. Esse é um dos motivos pelo qual, algumas documentações do Cassandra considera essa criação como ant-pattern.

TIP: Uma maneira eficiente de usar o índice secundário é utilizar-lho em parceria com a chave primária, partition key, assim ele será endereçado num range de nós específicos.

Existem algumas boas práticas ao se utilizar índices que são:

* *Não* utilizar quando existe um alto grau de cardinalidade
* *Não* utilizar em campos que são atualizados com uma alta frequência



=== Tipos no Cassandra

Dentro de uma família de colunas cada campo tem um tipo definido. Esse tipo define como o dado será armazenado dentro do banco de dados. No cassandra os tipos são devividos em três tipos:

* Tipos nativos
* Tipos de coleção
* User-defined-type UDT
* Tuplas

==== Tipos nativos

Os tipos nativos, são os tipos do qual o Cassandra já tem suporte e não é necessário realizar nenhuma modificação ou criação dentro do banco de dados.


.Os principais tipos nativos do Cassandra
|===
| Tipo | descrição
| --- | ---
|ascii|ASCII String
|bigint|Um long 64-bit signed
|blob|Um grande array de bytes
|boolean|Tem o valor true ou falso
|counter|Uma coluna contadora (long 64-bit signed)
|date|Uma data
|decimal|Um tipo de precisão decimal
|double|64-bit IEEE-754 de ponto flutuante
|duration|Um tipo de duração com precisão em nanosegundos
|float|32-bit IEEE-754 floating point
|inet|Um endereço IP
|int|32-bit signed int
|smallint|16-bit signed int
|text| Uma String como UTF8
|time|Uma data com precisão em nanosegundos
|timestamp|Um timestamp com precisão em milisegundos
|timeuuid|Version 1 UUID, generally used as a “conflict-free” timestamp. Also see Timeuuid functions
|uuid|A UUID (of any version)
|varchar|Uma String em UTF8
|===


==== Coleções

Dentro do Cassandra existe suporte para três tipos de coleções que seguem a mesma linha do mundo Java. Essas coleções se encaixam perfeitamente quando é necessário ter um campo que um conjunto de itens, por exemplo, a lista de telefones ou de contatos.

[source,sql]
----
collection_type ::=  MAP '<' cql_type ',' cql_type '>'
                     | SET '<' cql_type '>'
                     | LIST '<' cql_type '>'
----

===== List

É a uma sequência de itens ordenado pela posição da qual foi adicionado, por exemplo, dado uma família de coluna de leitores é possível ter uma lista livros que o mesmo já leu. Assim:


.Criação da família de coluna de leitores
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books list<text>,
    PRIMARY KEY (name)
);

INSERT INTO library.reader (name, books) VALUES ('Poliana', ['The Shack','The Love','Clean Code']);
INSERT INTO library.reader (name, books) VALUES ('David', ['Clean Code','Effectove Java','Clean Code']);

cqlsh> SELECT * FROM library.reader;

 name    | books
---------+------------------------------------------------
   David | ['Clean Code', 'Effectove Java', 'Clean Code']
 Poliana |        ['The Shack', 'The Love', 'Clean Code']

(2 rows)

----

Dentro da lista é possível tanto substituir a corrente lista, alterar um único elemento ou adicionar novos elementos que será mostrado respectivamente.


[source,sql]
----
//repleace
cqlsh> UPDATE library.reader SET books = [ 'Java EE 8'] WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';

 name    | books
---------+-----------------------------------------
   David |                           ['Java EE 8']

//appending
UPDATE library.reader SET books = books + [ 'Clean Code'] WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';
 name  | books
-------+-----------------------------
 David | ['Java EE 8', 'Clean Code']

//update an element
UPDATE library.reader SET books[1]= 'Clean Architecture' WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';
 name  | books
-------+-------------------------------------
 David | ['Java EE 8', 'Clean Architecture']

----

Também é possível remover os elementos com o `DELETE` além de remover elementos com o `UPDATE`.

[source,sql]
----
DELETE books[1] FROM library.reader where name = 'David';
cqlsh> SELECT * FROM library.reader WHERE name= 'David';

 name  | books
-------+---------------
 David | ['Java EE 8']


UPDATE library.reader SET books = books - [ 'Java EE 8' ] WHERE name = 'David';
cqlsh> SELECT * FROM library.reader WHERE name= 'David';
 name  | books
-------+-------
 David |  null
----

===== Set

O Set é similar com o List, porém, ele não permite valores duplicados, assim, utilizando o mesmo exemplo citado anteriormente, porém, com Set teremos:

.Criação da família de coluna de leitores, dessa vez, é possível ver que o livro “Clean Code” do leitor “David” não aparece mais duplicado.
[source,sql]
----
DROP TABLE IF EXISTS library.reader;

CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books set<text>,
    PRIMARY KEY (name)
);

INSERT INTO library.reader (name, books) VALUES ('Poliana', {'The Shack','The Love','Clean Code'});
INSERT INTO library.reader (name, books) VALUES ('David', {'Clean Code','Effectove Java','Clean Code'});

cqlsh> SELECT * FROM library.reader;

 name    | books
---------+----------------------------------------
   David |        {'Clean Code', 'Effectove Java'}
 Poliana | {'Clean Code', 'The Love', 'The Shack'}

(2 rows)

----

Dentro do Set é possível tanto substituir a corrente coleção ou adicionar novos elementos que será mostrado respectivamente.


[source,sql]
----
//repleace
cqlsh> UPDATE library.reader SET books = { 'Java EE 8'} WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';

 name    | books
---------+-----------------------------------------
   David |                           {'Java EE 8'}

//appending
UPDATE library.reader SET books = books + { 'Clean Code'} WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';
 name  | books
-------+-----------------------------
 David | {'Java EE 8', 'Clean Code'}

----

TIP: Como recomendação o tipo `List` tem algumas limitações e problemas de performance comparado ao `Set` caso possa escolher, sempre priorize o `Set`.


===== Map

O mapa ele segue a linha de um dicionário de dados ou de um java.util.Map, caso você seja do mundo Java. Por exemplo, dado o exemplo anteior de leitores, nós gostaríamos de adicionar informações de contato. Esse contato pode ser de inúmeras formas, por exemplo, via e-mail, telefone, twitter, etc. Um bom candidato para isso seria o Map.


[source,sql]
----
DROP TABLE IF EXISTS library.reader;

CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books set<text>,
    contacts map<text,text>,
    PRIMARY KEY (name)
);
INSERT INTO library.reader (name, books, contacts) VALUES ('Poliana', {'The Shack','The Love','Clean Code'},
{'email': 'poliana@email.com','phone': '+1 55 486848635', 'twitter': 'polianatwitter', 'facebook': 'polianafacebook'});
INSERT INTO library.reader (name, books, contacts) VALUES ('David', {'Clean Code'}, {'email': 'david@email.com'
,'phone': '+1 55 48684865', 'twitter': 'davidtwitter'});

cqlsh> SELECT * FROM library.reader;

 name    | books                                   | contacts
---------+-----------------------------------------+------------------------------------------------------------------------------------------------------------------------
   David |                          {'Clean Code'} |                                     {'email': 'david@email.com', 'phone': '+1 55 48684865', 'twitter': 'davidtwitter'}
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'polianatwitter'}

----

Assim, como as coleções anteriores, é possível realizar alterações:

[source,sql]
----
//to update a key element
UPDATE library.reader SET contacts['twitter'] = 'fakeaccount' WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';

 name    | books                                   | contacts
---------+-----------------------------------------+---------------------------------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'fakeaccount'}
//to append a new entry
UPDATE library.reader SET contacts = contacts+ {'youtube':'youtubeaccount'} WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'fakeaccount', 'youtube': 'youtubeaccount'}
//remove an element
DELETE contacts['youtube'] FROM  library.reader where  name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+---------------------------------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'fakeaccount'}
//to remove elements by the key
UPDATE library.reader SET contacts = contacts - {'youtube','twitter'} WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+-------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635'}
// to repleace the whole map
UPDATE library.reader SET contacts= {'email': 'just@email.com'} WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+-----------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'just@email.com'}

----


==== Tupla

Uma tupla é uma combinação de Chave valor, para o mundo Java é semelhante ao java.util.Map.Entry. Sua estrutura de criação é:

[source,sql]
----
tuple_type    ::=  TUPLE '<' cql_type ( ',' cql_type )* '>'
tuple_literal ::=  '(' term ( ',' term )* ')'
----

Para esse exemplo, utilizando a mesma família de coluna de leitores, porém, assumiremos que apenas uma única informação de contato, independente de qual seja, é suficiente. Assim:

[source,sql]
----
DROP TABLE IF EXISTS library.reader;

CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books set<text>,
    contact tuple<text,text>,
    PRIMARY KEY (name)
);
INSERT INTO library.reader (name, books, contact) VALUES ('Poliana', {'The Shack','The Love','Clean Code'}, ('email', 'poliana@email.com'));
cqlsh> SELECT * FROM library.reader;

 name    | books                                   | contact
---------+-----------------------------------------+--------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | ('email', 'poliana@email.com')

----

WARNING: Diferente das coleções não é possível substituir um único elemento da tupla como apenas a chave ou o valor. É necessário atualizar todo o campo.


==== User-Defined Types

O user-defined Types, ou apenas UDT, é um tipo de dados criado pelo usuário. Esse tipo é criado a partir de um keyspace e segue o mesmo princípio de uma família de colunas, ou seja, será possível criar, alterar e dropar um UDT.

[source,sql]
----
create_type_statement ::=  CREATE TYPE [ IF NOT EXISTS ] udt_name
                               '(' field_definition ( ',' field_definition )* ')'
field_definition      ::=  identifier cql_type
----

Assim, como o tipo nativo, para ser utilizado é necessário defini-lo dentro de uma família de coluna. Por exemplo, para informação de um usuário da biblioteca é necessário o endereço, e nesse endereço terá o país e a cidade.

[source,sql]
----
CREATE TYPE IF NOT EXISTS library.name (
    first_name text,
    last_name text,
);
CREATE TABLE IF NOT EXISTS library.user (
    id text,
    name name,
    PRIMARY KEY (id)
);
INSERT INTO library.user (id, name) values ('otaviojava', {first_name: 'Otavio', last_name: 'Santana'});
INSERT INTO library.user (id, name) values ('poliana', {first_name: 'Poliana', last_name: 'Santana'});
cqlsh> SELECT * FROM library.user;

 id         | name
------------+-----------------------------------------------
    poliana | {first_name: 'Poliana', last_name: 'Santana'}
 otaviojava |  {first_name: 'Otavio', last_name: 'Santana'}
----

Por exemplo, dado o tipo nome, será adicionado o campo nome do meio.


[source,sql]
----
ALTER TYPE library.name ADD middle_name text;
cqlsh> SELECT * FROM library.user;

 id         | name
------------+------------------------------------------------------------------
    poliana | {first_name: 'Poliana', last_name: 'Santana', middle_name: null}
 otaviojava |  {first_name: 'Otavio', last_name: 'Santana', middle_name: null}

INSERT INTO library.user (id, name) values ('otaviojava', {first_name: 'Otavio', last_name: 'Santana', middle_name: 'Gonçalves'});
INSERT INTO library.user (id, name) values ('poliana', {first_name: 'Poliana', last_name: 'Santana', middle_name: 'Santos'});

cqlsh> SELECT * FROM library.user;
 id         | name
------------+------------------------------------------------------------------------
    poliana |   {first_name: 'Poliana', last_name: 'Santana', middle_name: 'Santos'}
 otaviojava | {first_name: 'Otavio', last_name: 'Santana', middle_name: 'Gonçalves'}
----

Também é possível remover remover o UDT como `DROP UDT`.

[source,sql]
----
drop_type_statement ::=  DROP TYPE [ IF EXISTS ] udt_name
----

Por exemplo, ao remover o campo nome da família de colunas:

[source,sql]
----
ALTER COLUMNFAMILY library.user DROP name;
cqlsh> SELECT * FROM library.user;
 id
------------
    poliana
 otaviojava

DROP TYPE IF EXISTS library.name;
----

Também é possível criar uma coleção de UDTs, para isso é necessário utilizar o keyword `frozen`, vale salientar que o UDT tem o seu funcionamento semelhante de uma tupla, ou seja, não é possível  alterar um único elemento.

[source,sql]
----
DROP TABLE IF EXISTS library.user;
DROP TABLE IF EXISTS library.user;
CREATE TYPE IF NOT EXISTS library.phone (
    country_code int,
    number text,
);
CREATE TABLE IF NOT EXISTS library.user (
    id text,
    phones set<frozen<phone>>,
    PRIMARY KEY (id)
);
----


=== Manipulando informação
==== Select
==== Insert
==== Update
==== Delete
==== Batch
=== View materilizada
=== Segurança


