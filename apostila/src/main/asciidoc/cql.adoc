
== Conhecendo o CQL

A comunicação com o banco de dados seja para a criação de tabelas, manipulação de dados é
certamente a coisa mais trivial num banco de dados, seja relacional, seja não relacional.
O Cassandra oferece sua própria linguagem para comunicação com o banco de dados,
o Cassandra Query language ou CQL. O CQL oferece uma linguagem próximo ao SQL, porém, de maneira mais simples uma vez que, por exemplo, não existe os conceitos de joins
(inner join, left join, dentre outros) dentro das buscas do Cassandra. Um desenvolvedor que já conheça o SQL terá uma curva de aprendizagem muito menor para aprender essa linguagem do Cassandra.
Esse capítulo terá o objetivo de falar um pouco sobre essa linguagem.

TIP: Para essas operações utilizaremos o client cqlsh que explicamos o seu acesso no capítulo anterior.

=== Keyspace

A nossa primeira parada no CQL é a criação da maior estrutura dentro da hierarquia do Cassandra, sim o keyspace. É durante a criação do keyspace que é definido a estratégia de replicação e o fator de réplica para os dados. O template da criação é mostrado a seguir:

[source,sql]
----
create_keyspace_statement ::=  CREATE KEYSPACE [ IF NOT EXISTS ] keyspace_name WITH options
----

Por exemplo, ao se criar um keyspace de livraria:

[source,sql]
----
CREATE KEYSPACE library  WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
//or
CREATE KEYSPACE library
           WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1' : 1, 'DC2' : 3}
            AND durable_writes = false;
----

Realizado a criação do novo keyspace é possível verificar os keyspaces criados no Cassandra para isso realizaremos a nossa primeira query. `select * from system_schema.keyspaces;` é possível perceber a semelhança com o banco de dados relacional. Falaremos mais sobre buscar informações nos itens a seguir.

.Resultado simplicado da busca pelo keyspace 'library'
[source,sql]
----
cqlsh> select * from system_schema.keyspaces where keyspace_name= 'library';

 keyspace_name |replication
---------------+------------------------------------------------------
       library |{'class': 'SimpleStrategy', 'replication_factor': '3'}

(1 rows)
----

Uma vez criado o keyspace é possível realizar alguma alteração do mesmo, para isso é necessário utilizar o *alter keyspace*. O template é mostrado a seguir:

[source,sql]
----
alter_keyspace_statement ::=  ALTER KEYSPACE keyspace_name WITH options
----

Por exemplo, alterando o keyspace library:

[source,sql]
----
ALTER KEYSPACE Excelsior WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 4};
----

Também é possível remover o keyspace com o *drop keyspace*, no nosso exemplo:

[source,sql]
----
DROP KEYSPACE library;
----

O que acontece caso se remova ou se crie duas vezes o mesmo keyspace?
Caso o usuário tenta criar ou remover mais de uma vez a mesma tabela, uma mensagem de erro é gerada. Por exemplo, `Keyspace 'library' already exists` ou `ConfigurationException: Cannot drop non existing keyspace 'library'.` para criar ou remover respectivamente. Uma maneira de evitar tal erro é realizar essa alteração caso realmente faça sentido, por exemplo, só crie caso ela não exista ou só remova caso ela exista. Com esse objetivo a sintaxe suporta essa condição, usando o mesmo exemplo de livraria executando o a criação e a remoção de maneira segura.


[source,sql]
----
DROP KEYSPACE IF EXISTS library;
CREATE KEYSPACE IF NOT EXISTS library  WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
----

=== Familia de Colunas

A criação da família de coluna de maneira análoga é semelhante a criação da tabela é nela que são definidos os campos, partition key, clustering key, o índice, e mais configurações, para isso basta utilizar o template `CREATE TABLE`:


[source,sql]
----
create_table_statement ::=  CREATE TABLE [ IF NOT EXISTS ] table_name
                            '('
                                column_definition
                                ( ',' column_definition )*
                                [ ',' PRIMARY KEY '(' primary_key ')' ]
                            ')' [ WITH table_options ]
column_definition      ::=  column_name cql_type [ STATIC ] [ PRIMARY KEY]
primary_key            ::=  partition_key [ ',' clustering_columns ]
partition_key          ::=  column_name
                            | '(' column_name ( ',' column_name )* ')'
clustering_columns     ::=  column_name ( ',' column_name )*
table_options          ::=  COMPACT STORAGE [ AND table_options ]
                            | CLUSTERING ORDER BY '(' clustering_order ')' [ AND table_options ]
                            | options
clustering_order       ::=  column_name (ASC | DESC) ( ',' column_name (ASC | DESC) )*
----

Por exemplo, dado que foi criado o keyspace library o próximo passo é criar a família de coluna de livros:

.A simples criação de uma família de coluna de livros do qual temos o nome como a chave (que deve ser única e, atualmente, é a única forma de buscar o livro).
[source,sql]
----
CREATE TABLE library.book (
    name text PRIMARY KEY,
       year int
);
----

TIP: É possível também verificar a família de coluna existe antes de criar, utilizando o `IF NOT EXISTS` semelhante ao keyspace.

Também é possível realizar alterações na família de coluna, por exemplo, adicionar ou remover um campo dentro da família de coluna. Para isso, é necessário utilizar o seguinte template:

[source,sql]
----
alter_table_statement   ::=  ALTER TABLE table_name alter_table_instruction
alter_table_instruction ::=  ADD column_name cql_type ( ',' column_name cql_type )*
                             | DROP column_name ( column_name )*
                             | WITH options
----

Por exemplo, adicionar o campo autor:

[source,sql]
----
ALTER TABLE library.book ADD author text;
----

Caso queria remover o mesmo campo:

[source,sql]
----
ALTER TABLE library.book DROP author;
----

Também é possível destruir a estrutura recém-criada.

[source,sql]
----
drop_table_statement ::=  DROP TABLE [ IF EXISTS ] table_name
----

No nosso exemplo:

[source,sql]
----
DROP TABLE IF EXISTS library.book;
----

Existem caso que o objetivo não distruir a estrutura, mas remover todo o conteúdo e manter a estrutura, para isso, é possível truncar a família de coluna. Para isso, existe o comando `TRUNCATE`.

[source,sql]
----
truncate_statement ::=  TRUNCATE [ TABLE ] table_name
----


Por exemplo, ao se criar novamente a família de coluna e adicionamos alguns livros, em seguida, truncamos a tabela e verificamos o resultado.


.Criação da tabela `book` e a inserção de dois livros
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.book (
    name text PRIMARY KEY,
       year int
);
INSERT INTO library.book  JSON '{"name": "Effective Java", "year": 2001}';
INSERT INTO library.book  JSON '{"name": "Clean Code", "year": 2008}';
----

.Executando a query para buscar o resultado
[source,sql]
----
cqlsh> SELECT * FROM library.book;

 name           | year
----------------+------
     Clean Code | 2008
 Effective Java | 2001

(2 rows)
----

[source,sql]
----
TRUNCATE library.book;
----

.Executando a query para buscar o resultado
[source,sql]
----
cqlsh> SELECT * FROM library.book;

 name | year
------+------

(0 rows)

----

==== Chave primária

Dentro da família de coluna a chave primária, primary key, é o campo único e todas as famílias de colunas *devem* defini-la. É a partir desse campo que o os dados serão recuperados, por issso, existe uma preocupação inicial com esse campo. A chave primária pode ser constituída por mais de um campo, porém, ela terá um conceito diferente do banco relacional. Ele será dividida em duas partes:

* The *partition key*: É a primeira parte da chave primária. É nesse campo que será definido o hash onde será definido onde os dados serão enviados. Ou seja, valores com o mesmo parition key tendem a ser enviados para os mesmos clusters e é ele que definirá como os dados serão distribuídos através dos clusters.
* O *clustering columns*: Essa chave tem o poder de definir a ordem dentro da tabela, por exemplo, ao criar uma família de autores definimos o nome como chave e seus livros como ordem.


[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    PRIMARY KEY (name, book)
);
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Agile Principles, Patterns", "year": 2006}';
----

Ao executar a query teremos o seguinte resultado:

[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book                       | year
---------------------+----------------------------+------
 Robert Cecil Martin | Agile Principles, Patterns | 2006
 Robert Cecil Martin |         Clean Architecture | 2017
 Robert Cecil Martin |                 Clean Code | 2008

(3 rows)
----

Uma outra opção é, remover a tabela e criar novamente, dessa vez com a ordem dos livros de maneira decrescente. Assim:

[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    PRIMARY KEY (name, book)
)
WITH CLUSTERING ORDER BY (book DESC);

INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Agile Principles, Patterns", "year": 2006}';
----


[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book                       | year
---------------------+----------------------------+------
 Robert Cecil Martin |                 Clean Code | 2008
 Robert Cecil Martin |         Clean Architecture | 2017
 Robert Cecil Martin | Agile Principles, Patterns | 2006

(3 rows)

----
Apenas recapitulando, dentre outros objetivos é a partir da chave é possível realizar a busca das informações, por exemplo, utilizando nossa pequena estrutura de dados de autores:


.Realizando a busca a partir da chave, nome do autor do livro.
[source,sql]
----
cqlsh> SELECT book FROM library.author WHERE name = 'Robert Cecil Martin';

 book
----------------------------
                 Clean Code
         Clean Architecture
 Agile Principles, Patterns

(3 rows)
----

Caso seja necessário realizar a busca por um campo que não seja a chave, partition key, isso não será possível. Assim, no nosso exemplo, tanto a busca pelo livro e pelo ano dará a mesma mensagem de erro.

.Ao tentar executar a query é retornado um erro, não é possível ler da família de coluna de forma eficiente.
[source,sql]
----
cqlsh> SELECT * FROM library.author WHERE year =2017;
InvalidRequest: Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"
cqlsh> SELECT * FROM library.author WHERE book  ='Clean Architecture';
InvalidRequest: Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"
----

Como mostra a mensagem de erro, a única maneira de executar a query é adicionando o comando `ALLOW FILTERING`, porém, isso terá sérias consequências de performance.

[source,sql]
----
cqlsh> SELECT * FROM library.author WHERE year =2017 ALLOW FILTERING;
 name                | book               | year
---------------------+--------------------+------
 Robert Cecil Martin | Clean Architecture | 2017
(1 rows)

cqlsh> SELECT * FROM library.author WHERE book  ='Clean Architecture' ALLOW FILTERING;
name                | book               | year
---------------------+--------------------+------
 Robert Cecil Martin | Clean Architecture | 2017

(1 rows)
----

A maneira da qual o cassandra executa esse comando é recuperando todas as linhas e então filtrando por aqueles que não tem o valor da condição. Por exemplo, uma família de colunas que tenha um milhão de linhas e 98% tenha a condição da query, isso será relativamente eficiente. Porém, imagine o caso de que apenas uma linha atenda a condição, ou seja, o Cassandra percorreu de maneira linear e ineficiente 999999 elementos para apenas retornar um.

WARNING: Se uma query é rejeitada pelo Cassandra pedindo o filtro, resita ao uso do `ALLOW FILTERING`. Verifique sua modelagem, seus dados e volumetria e verifique o que você realmente quer fazer.

TIP: Uma segunda opção é o uso de índices secundários que será abordado a seguir.

==== Tipos estáticos

Algumas colunas podem ser consideradas estáticas dentro da família de coluna. Uma coluna estática é uma coluna que compartilha o mesmo valor para todas as linhas que tenham o mesmo valor de partition key. Por exemplo, imagine o cenário de família de coluna autor (com nome e livro), e agora existe o desejo de se adicionar o campo país de residência. Uma vez que o autor mude de país é importante que todas as suas referências também sejam atualizadas, assim, criaremos o campo país como estático, exibido a seguir:


.Criando a estrutura de `author` agora com o campo estático país
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    country text static,
    PRIMARY KEY (name, book)
);
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "country": "USA", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Joshua Bloch", "book": "Effecive Java", "year": 2001}';
INSERT INTO library.author  JSON '{"name": "Joshua Bloch", "book": "JAVA PUZZLERS", "year": 2005, "country": "Brazil"}';
----

.Mesmo inserido uma única vez, ele foi persistido em todos os campos com a mesma chave.
[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book               | country | year
---------------------+--------------------+---------+------
        Joshua Bloch |      Effecive Java |  Brazil | 2001
        Joshua Bloch |      JAVA PUZZLERS |  Brazil | 2005
 Robert Cecil Martin | Clean Architecture |     USA | 2017
 Robert Cecil Martin |         Clean Code |     USA | 2008

(4 rows)

----


==== Índice secundário

=== Tipos no Cassandra

==== User-Defined Types

=== Manipulando informação
==== Select
==== Insert
==== Update
==== Delete
==== Batch
=== Indice secundário
=== View materilizada
=== Segurança


