
== Conhecendo o CQL

A comunicação com o banco de dados seja para a criação de tabelas, manipulação de dados é
certamente a coisa mais trivial num banco de dados, seja relacional, seja não relacional.
O Cassandra oferece sua própria linguagem para comunicação com o banco de dados,
o Cassandra Query language ou CQL. O CQL oferece uma linguagem próximo ao SQL, porém, de maneira mais simples uma vez que, por exemplo, não existe os conceitos de joins
(inner join, left join, dentre outros) dentro das buscas do Cassandra. Um desenvolvedor que já conheça o SQL terá uma curva de aprendizagem muito menor para aprender essa linguagem do Cassandra.
Esse capítulo terá o objetivo de falar um pouco sobre essa linguagem.

TIP: Para essas operações utilizaremos o client cqlsh que explicamos o seu acesso no capítulo anterior.

=== Keyspace

A nossa primeira parada no CQL é a criação da maior estrutura dentro da hierarquia do Cassandra, sim o keyspace. É durante a criação do keyspace que é definido a estratégia de replicação e o fator de réplica para os dados. O template da criação é mostrado a seguir:

[source,sql]
----
create_keyspace_statement ::=  CREATE KEYSPACE [ IF NOT EXISTS ] keyspace_name WITH options
----

Por exemplo, ao se criar um keyspace de livraria:

[source,sql]
----
CREATE KEYSPACE library  WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
//or
CREATE KEYSPACE library
           WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1' : 1, 'DC2' : 3}
            AND durable_writes = false;
----

Realizado a criação do novo keyspace é possível verificar os keyspaces criados no Cassandra para isso realizaremos a nossa primeira query. `select * from system_schema.keyspaces;` é possível perceber a semelhança com o banco de dados relacional. Falaremos mais sobre buscar informações nos itens a seguir.

.Resultado simplicado da busca pelo keyspace 'library'
[source,sql]
----
cqlsh> select * from system_schema.keyspaces where keyspace_name= 'library';

 keyspace_name |replication
---------------+------------------------------------------------------
       library |{'class': 'SimpleStrategy', 'replication_factor': '3'}

(1 rows)
----

Uma vez criado o keyspace é possível realizar alguma alteração do mesmo, para isso é necessário utilizar o *alter keyspace*. O template é mostrado a seguir:

[source,sql]
----
alter_keyspace_statement ::=  ALTER KEYSPACE keyspace_name WITH options
----

Por exemplo, alterando o keyspace library:

[source,sql]
----
ALTER KEYSPACE Excelsior WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 4};
----

Também é possível remover o keyspace com o *drop keyspace*, no nosso exemplo:

[source,sql]
----
DROP KEYSPACE library;
----

O que acontece caso se remova ou se crie duas vezes o mesmo keyspace?
Caso o usuário tenta criar ou remover mais de uma vez a mesma tabela, uma mensagem de erro é gerada. Por exemplo, `Keyspace 'library' already exists` ou `ConfigurationException: Cannot drop non existing keyspace 'library'.` para criar ou remover respectivamente. Uma maneira de evitar tal erro é realizar essa alteração caso realmente faça sentido, por exemplo, só crie caso ela não exista ou só remova caso ela exista. Com esse objetivo a sintaxe suporta essa condição, usando o mesmo exemplo de livraria executando o a criação e a remoção de maneira segura.


[source,sql]
----
DROP KEYSPACE IF EXISTS library;
CREATE KEYSPACE IF NOT EXISTS library  WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
----

=== Familia de Colunas

A criação da família de coluna de maneira análoga é semelhante a criação da tabela é nela que são definidos os campos, partition key, clustering key, o índice, e mais configurações, para isso basta utilizar o template `CREATE TABLE`:


[source,sql]
----
create_table_statement ::=  CREATE TABLE [ IF NOT EXISTS ] table_name
                            '('
                                column_definition
                                ( ',' column_definition )*
                                [ ',' PRIMARY KEY '(' primary_key ')' ]
                            ')' [ WITH table_options ]
column_definition      ::=  column_name cql_type [ STATIC ] [ PRIMARY KEY]
primary_key            ::=  partition_key [ ',' clustering_columns ]
partition_key          ::=  column_name
                            | '(' column_name ( ',' column_name )* ')'
clustering_columns     ::=  column_name ( ',' column_name )*
table_options          ::=  COMPACT STORAGE [ AND table_options ]
                            | CLUSTERING ORDER BY '(' clustering_order ')' [ AND table_options ]
                            | options
clustering_order       ::=  column_name (ASC | DESC) ( ',' column_name (ASC | DESC) )*
----

Por exemplo, dado que foi criado o keyspace library o próximo passo é criar a família de coluna de livros:

.A simples criação de uma família de coluna de livros do qual temos o nome como a chave (que deve ser única e, atualmente, é a única forma de buscar o livro).
[source,sql]
----
CREATE TABLE library.book (
    name text PRIMARY KEY,
       year int
);
----

TIP: É possível também verificar a família de coluna existe antes de criar, utilizando o `IF NOT EXISTS` semelhante ao keyspace.

Também é possível realizar alterações na família de coluna, por exemplo, adicionar ou remover um campo dentro da família de coluna. Para isso, é necessário utilizar o seguinte template:

[source,sql]
----
alter_table_statement   ::=  ALTER TABLE table_name alter_table_instruction
alter_table_instruction ::=  ADD column_name cql_type ( ',' column_name cql_type )*
                             | DROP column_name ( column_name )*
                             | WITH options
----

Por exemplo, adicionar o campo autor:

[source,sql]
----
ALTER TABLE library.book ADD author text;
----

Caso queria remover o mesmo campo:

[source,sql]
----
ALTER TABLE library.book DROP author;
----

Também é possível destruir a estrutura recém-criada.

[source,sql]
----
drop_table_statement ::=  DROP TABLE [ IF EXISTS ] table_name
----

No nosso exemplo:

[source,sql]
----
DROP TABLE IF EXISTS library.book;
----

Existem caso que o objetivo não distruir a estrutura, mas remover todo o conteúdo e manter a estrutura, para isso, é possível truncar a família de coluna. Para isso, existe o comando `TRUNCATE`.

[source,sql]
----
truncate_statement ::=  TRUNCATE [ TABLE ] table_name
----


Por exemplo, ao se criar novamente a família de coluna e adicionamos alguns livros, em seguida, truncamos a tabela e verificamos o resultado.


.Criação da tabela `book` e a inserção de dois livros
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.book (
    name text PRIMARY KEY,
       year int
);
INSERT INTO library.book  JSON '{"name": "Effective Java", "year": 2001}';
INSERT INTO library.book  JSON '{"name": "Clean Code", "year": 2008}';
----

.Executando a query para buscar o resultado
[source,sql]
----
cqlsh> SELECT * FROM library.book;

 name           | year
----------------+------
     Clean Code | 2008
 Effective Java | 2001

(2 rows)
----

[source,sql]
----
TRUNCATE library.book;
----

.Executando a query para buscar o resultado
[source,sql]
----
cqlsh> SELECT * FROM library.book;

 name | year
------+------

(0 rows)

----

TIP: É possível utilizar também `COLUMNFAMILY` ao invés de `TABLE`
==== Chave primária

Dentro da família de coluna a chave primária, primary key, é o campo único e todas as famílias de colunas *devem* defini-la. É a partir desse campo que o os dados serão recuperados, por issso, existe uma preocupação inicial com esse campo. A chave primária pode ser constituída por mais de um campo, porém, ela terá um conceito diferente do banco relacional. Ele será dividida em duas partes:

* The *partition key*: É a primeira parte da chave primária. É nesse campo que será definido o hash onde será definido onde os dados serão enviados. Ou seja, valores com o mesmo parition key tendem a ser enviados para os mesmos clusters e é ele que definirá como os dados serão distribuídos através dos clusters.
* O *clustering columns*: Essa chave tem o poder de definir a ordem dentro da tabela, por exemplo, ao criar uma família de autores definimos o nome como chave e seus livros como ordem.


[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    PRIMARY KEY (name, book)
);
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Agile Principles, Patterns", "year": 2006}';
----

Ao executar a query teremos o seguinte resultado:

[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book                       | year
---------------------+----------------------------+------
 Robert Cecil Martin | Agile Principles, Patterns | 2006
 Robert Cecil Martin |         Clean Architecture | 2017
 Robert Cecil Martin |                 Clean Code | 2008

(3 rows)
----

Uma outra opção é, remover a tabela e criar novamente, dessa vez com a ordem dos livros de maneira decrescente. Assim:

[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    PRIMARY KEY (name, book)
)
WITH CLUSTERING ORDER BY (book DESC);

INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Agile Principles, Patterns", "year": 2006}';
----


[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book                       | year
---------------------+----------------------------+------
 Robert Cecil Martin |                 Clean Code | 2008
 Robert Cecil Martin |         Clean Architecture | 2017
 Robert Cecil Martin | Agile Principles, Patterns | 2006

(3 rows)

----
Apenas recapitulando, dentre outros objetivos é a partir da chave é possível realizar a busca das informações, por exemplo, utilizando nossa pequena estrutura de dados de autores:


.Realizando a busca a partir da chave, nome do autor do livro.
[source,sql]
----
cqlsh> SELECT book FROM library.author WHERE name = 'Robert Cecil Martin';

 book
----------------------------
                 Clean Code
         Clean Architecture
 Agile Principles, Patterns

(3 rows)
----

Caso seja necessário realizar a busca por um campo que não seja a chave, partition key, isso não será possível. Assim, no nosso exemplo, tanto a busca pelo livro e pelo ano dará a mesma mensagem de erro.

.Ao tentar executar a query é retornado um erro, não é possível ler da família de coluna de forma eficiente.
[source,sql]
----
cqlsh> SELECT * FROM library.author WHERE year =2017;
InvalidRequest: Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"
cqlsh> SELECT * FROM library.author WHERE book  ='Clean Architecture';
InvalidRequest: Error from server: code=2200 [Invalid query] message="Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"
----

Como mostra a mensagem de erro, a única maneira de executar a query é adicionando o comando `ALLOW FILTERING`, porém, isso terá sérias consequências de performance.

[source,sql]
----
cqlsh> SELECT * FROM library.author WHERE year =2017 ALLOW FILTERING;
 name                | book               | year
---------------------+--------------------+------
 Robert Cecil Martin | Clean Architecture | 2017
(1 rows)

cqlsh> SELECT * FROM library.author WHERE book  ='Clean Architecture' ALLOW FILTERING;
name                | book               | year
---------------------+--------------------+------
 Robert Cecil Martin | Clean Architecture | 2017

(1 rows)
----

A maneira da qual o cassandra executa esse comando é recuperando todas as linhas e então filtrando por aqueles que não tem o valor da condição. Por exemplo, uma família de colunas que tenha um milhão de linhas e 98% tenha a condição da query, isso será relativamente eficiente. Porém, imagine o caso de que apenas uma linha atenda a condição, ou seja, o Cassandra percorreu de maneira linear e ineficiente 999999 elementos para apenas retornar um.

WARNING: Se uma query é rejeitada pelo Cassandra pedindo o filtro, resita ao uso do `ALLOW FILTERING`. Verifique sua modelagem, seus dados e volumetria e verifique o que você realmente quer fazer.

TIP: Uma segunda opção é o uso de índices secundários que será abordado a seguir.

==== Tipos estáticos

Algumas colunas podem ser consideradas estáticas dentro da família de coluna. Uma coluna estática é uma coluna que compartilha o mesmo valor para todas as linhas que tenham o mesmo valor de partition key. Por exemplo, imagine o cenário de família de coluna autor (com nome e livro), e agora existe o desejo de se adicionar o campo país de residência. Uma vez que o autor mude de país é importante que todas as suas referências também sejam atualizadas, assim, criaremos o campo país como estático, exibido a seguir:


.Criando a estrutura de `author` agora com o campo estático país
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.author (
    name text,
    book text,
    year int,
    country text static,
    PRIMARY KEY (name, book)
);
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Architecture", "year": 2017}';
INSERT INTO library.author  JSON '{"name": "Robert Cecil Martin", "book": "Clean Code", "country": "USA", "year": 2008}';
INSERT INTO library.author  JSON '{"name": "Joshua Bloch", "book": "Effecive Java", "year": 2001}';
INSERT INTO library.author  JSON '{"name": "Joshua Bloch", "book": "JAVA PUZZLERS", "year": 2005, "country": "Brazil"}';
----

.Mesmo inserido uma única vez, ele foi persistido em todos os campos com a mesma chave.
[source,sql]
----
cqlsh> SELECT * FROM library.author;

 name                | book               | country | year
---------------------+--------------------+---------+------
        Joshua Bloch |      Effecive Java |  Brazil | 2001
        Joshua Bloch |      JAVA PUZZLERS |  Brazil | 2005
 Robert Cecil Martin | Clean Architecture |     USA | 2017
 Robert Cecil Martin |         Clean Code |     USA | 2008

(4 rows)

----


==== Índice secundário


Existe uma outra opção para buscar as informações da tabela além da chave primária, que é o índice secundário. Ele permite a busca de informação sem que gera o erro do `ALLOW FILTERING` o seu template é exibido a seguir:

[source,sql]
----
index_name ::=  re('[a-zA-Z_0-9]+')
----

Por exemplo, realizar uma busca pelo campo ano na família de coluna de autores é possível com a criação de um índice secundário:


[source,sql]
----
index_name ::=  re('[a-zA-Z_0-9]+')
----

Por exemplo, realizar uma busca pelo campo ano na família de coluna de autores é possível executar o seguinte comando:

[source,sql]
----
CREATE INDEX year_index ON library.author (year);
----

Assim, finalmente é possível executar a query a partir do ano:

[source,sql]
----
cqlsh> SELECT * FROM library.author where year = 2005;

 name         | book          | country | year
--------------+---------------+---------+------
 Joshua Bloch | JAVA PUZZLERS |  Brazil | 2005

(1 rows)
----

Também é possível remover o índice criado com o DROP INDEX:

[source,sql]
----
drop_index_statement ::=  DROP INDEX [ IF EXISTS ] index_name
----

No nosso exemplo:

[source,sql]
----
DROP  INDEX IF EXISTS library.year_index;
----


==== Como funciona o índice secundário

Os índices secundários são criados para uma coluna dentro de uma família de coluna. Esses índices são armazenados localmente para cada nó e é criado em backgroug. If uma query baseada em índice secundário é utilizado, ou seja, não é restrito pela chave, dessa maneira aumentará a latência uma vez que não limitado pela chave e todos os nós serão consultados. Esse é um dos motivos pelo qual, algumas documentações do Cassandra considera essa criação como ant-pattern.

TIP: Uma maneira eficiente de usar o índice secundário é utilizar-lho em parceria com a chave primária, partition key, assim ele será endereçado num range de nós específicos.

Existem algumas boas práticas ao se utilizar índices que são:

* *Não* utilizar quando existe um alto grau de cardinalidade
* *Não* utilizar em campos que são atualizados com uma alta frequência



=== Tipos no Cassandra

Dentro de uma família de colunas cada campo tem um tipo definido. Esse tipo define como o dado será armazenado dentro do banco de dados. No cassandra os tipos são devividos em três tipos:

* Tipos nativos
* Tipos de coleção
* User-defined-type UDT
* Tuplas

==== Tipos nativos

Os tipos nativos, são os tipos do qual o Cassandra já tem suporte e não é necessário realizar nenhuma modificação ou criação dentro do banco de dados.


.Os principais tipos nativos do Cassandra
|===
| Tipo | descrição
| --- | ---
|ascii|ASCII String
|bigint|Um long 64-bit signed
|blob|Um grande array de bytes
|boolean|Tem o valor true ou falso
|counter|Uma coluna contadora (long 64-bit signed)
|date|Uma data
|decimal|Um tipo de precisão decimal
|double|64-bit IEEE-754 de ponto flutuante
|duration|Um tipo de duração com precisão em nanosegundos
|float|32-bit IEEE-754 floating point
|inet|Um endereço IP
|int|32-bit signed int
|smallint|16-bit signed int
|text| Uma String como UTF8
|time|Uma data com precisão em nanosegundos
|timestamp|Um timestamp com precisão em milisegundos
|timeuuid|Version 1 UUID, generally used as a “conflict-free” timestamp. Also see Timeuuid functions
|uuid|A UUID (of any version)
|varchar|Uma String em UTF8
|===


==== Coleções

Dentro do Cassandra existe suporte para três tipos de coleções que seguem a mesma linha do mundo Java. Essas coleções se encaixam perfeitamente quando é necessário ter um campo que um conjunto de itens, por exemplo, a lista de telefones ou de contatos.

[source,sql]
----
collection_type ::=  MAP '<' cql_type ',' cql_type '>'
                     | SET '<' cql_type '>'
                     | LIST '<' cql_type '>'
----

===== List

É a uma sequência de itens ordenado pela posição da qual foi adicionado, por exemplo, dado uma família de coluna de leitores é possível ter uma lista livros que o mesmo já leu. Assim:


.Criação da família de coluna de leitores
[source,sql]
----
CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books list<text>,
    PRIMARY KEY (name)
);

INSERT INTO library.reader (name, books) VALUES ('Poliana', ['The Shack','The Love','Clean Code']);
INSERT INTO library.reader (name, books) VALUES ('David', ['Clean Code','Effectove Java','Clean Code']);

cqlsh> SELECT * FROM library.reader;

 name    | books
---------+------------------------------------------------
   David | ['Clean Code', 'Effectove Java', 'Clean Code']
 Poliana |        ['The Shack', 'The Love', 'Clean Code']

(2 rows)

----

Dentro da lista é possível tanto substituir a corrente lista, alterar um único elemento ou adicionar novos elementos que será mostrado respectivamente.


[source,sql]
----
//repleace
cqlsh> UPDATE library.reader SET books = [ 'Java EE 8'] WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';

 name    | books
---------+-----------------------------------------
   David |                           ['Java EE 8']

//appending
UPDATE library.reader SET books = books + [ 'Clean Code'] WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';
 name  | books
-------+-----------------------------
 David | ['Java EE 8', 'Clean Code']

//update an element
UPDATE library.reader SET books[1]= 'Clean Architecture' WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';
 name  | books
-------+-------------------------------------
 David | ['Java EE 8', 'Clean Architecture']

----

Também é possível remover os elementos com o `DELETE` além de remover elementos com o `UPDATE`.

[source,sql]
----
DELETE books[1] FROM library.reader where name = 'David';
cqlsh> SELECT * FROM library.reader WHERE name= 'David';

 name  | books
-------+---------------
 David | ['Java EE 8']


UPDATE library.reader SET books = books - [ 'Java EE 8' ] WHERE name = 'David';
cqlsh> SELECT * FROM library.reader WHERE name= 'David';
 name  | books
-------+-------
 David |  null
----

===== Set

O Set é similar com o List, porém, ele não permite valores duplicados, assim, utilizando o mesmo exemplo citado anteriormente, porém, com Set teremos:

.Criação da família de coluna de leitores, dessa vez, é possível ver que o livro “Clean Code” do leitor “David” não aparece mais duplicado.
[source,sql]
----
DROP TABLE IF EXISTS library.reader;

CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books set<text>,
    PRIMARY KEY (name)
);

INSERT INTO library.reader (name, books) VALUES ('Poliana', {'The Shack','The Love','Clean Code'});
INSERT INTO library.reader (name, books) VALUES ('David', {'Clean Code','Effectove Java','Clean Code'});

cqlsh> SELECT * FROM library.reader;

 name    | books
---------+----------------------------------------
   David |        {'Clean Code', 'Effectove Java'}
 Poliana | {'Clean Code', 'The Love', 'The Shack'}

(2 rows)

----

Dentro do Set é possível tanto substituir a corrente coleção ou adicionar novos elementos que será mostrado respectivamente.


[source,sql]
----
//repleace
cqlsh> UPDATE library.reader SET books = { 'Java EE 8'} WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';

 name    | books
---------+-----------------------------------------
   David |                           {'Java EE 8'}

//appending
UPDATE library.reader SET books = books + { 'Clean Code'} WHERE name = 'David';
cqlsh> SELECT * FROM library.reader where name = 'David';
 name  | books
-------+-----------------------------
 David | {'Java EE 8', 'Clean Code'}

----

TIP: Como recomendação o tipo `List` tem algumas limitações e problemas de performance comparado ao `Set` caso possa escolher, sempre priorize o `Set`.


===== Map

O mapa ele segue a linha de um dicionário de dados ou de um java.util.Map, caso você seja do mundo Java. Por exemplo, dado o exemplo anteior de leitores, nós gostaríamos de adicionar informações de contato. Esse contato pode ser de inúmeras formas, por exemplo, via e-mail, telefone, twitter, etc. Um bom candidato para isso seria o Map.


[source,sql]
----
DROP TABLE IF EXISTS library.reader;

CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books set<text>,
    contacts map<text,text>,
    PRIMARY KEY (name)
);
INSERT INTO library.reader (name, books, contacts) VALUES ('Poliana', {'The Shack','The Love','Clean Code'},
{'email': 'poliana@email.com','phone': '+1 55 486848635', 'twitter': 'polianatwitter', 'facebook': 'polianafacebook'});
INSERT INTO library.reader (name, books, contacts) VALUES ('David', {'Clean Code'}, {'email': 'david@email.com'
,'phone': '+1 55 48684865', 'twitter': 'davidtwitter'});

cqlsh> SELECT * FROM library.reader;

 name    | books                                   | contacts
---------+-----------------------------------------+------------------------------------------------------------------------------------------------------------------------
   David |                          {'Clean Code'} |                                     {'email': 'david@email.com', 'phone': '+1 55 48684865', 'twitter': 'davidtwitter'}
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'polianatwitter'}

----

Assim, como as coleções anteriores, é possível realizar alterações:

[source,sql]
----
//to update a key element
UPDATE library.reader SET contacts['twitter'] = 'fakeaccount' WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';

 name    | books                                   | contacts
---------+-----------------------------------------+---------------------------------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'fakeaccount'}
//to append a new entry
UPDATE library.reader SET contacts = contacts+ {'youtube':'youtubeaccount'} WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'fakeaccount', 'youtube': 'youtubeaccount'}
//remove an element
DELETE contacts['youtube'] FROM  library.reader where  name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+---------------------------------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635', 'twitter': 'fakeaccount'}
//to remove elements by the key
UPDATE library.reader SET contacts = contacts - {'youtube','twitter'} WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+-------------------------------------------------------------------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'poliana@email.com', 'facebook': 'polianafacebook', 'phone': '+1 55 486848635'}
// to repleace the whole map
UPDATE library.reader SET contacts= {'email': 'just@email.com'} WHERE name = 'Poliana';
cqlsh> SELECT * from library.reader where name = 'Poliana';
 name    | books                                   | contacts
---------+-----------------------------------------+-----------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | {'email': 'just@email.com'}

----


==== Tupla

Uma tupla é uma combinação de Chave valor, para o mundo Java é semelhante ao java.util.Map.Entry. Sua estrutura de criação é:

[source,sql]
----
tuple_type    ::=  TUPLE '<' cql_type ( ',' cql_type )* '>'
tuple_literal ::=  '(' term ( ',' term )* ')'
----

Para esse exemplo, utilizando a mesma família de coluna de leitores, porém, assumiremos que apenas uma única informação de contato, independente de qual seja, é suficiente. Assim:

[source,sql]
----
DROP TABLE IF EXISTS library.reader;

CREATE TABLE IF NOT EXISTS library.reader (
    name text,
    books set<text>,
    contact tuple<text,text>,
    PRIMARY KEY (name)
);
INSERT INTO library.reader (name, books, contact) VALUES ('Poliana', {'The Shack','The Love','Clean Code'}, ('email', 'poliana@email.com'));
cqlsh> SELECT * FROM library.reader;

 name    | books                                   | contact
---------+-----------------------------------------+--------------------------------
 Poliana | {'Clean Code', 'The Love', 'The Shack'} | ('email', 'poliana@email.com')

----

WARNING: Diferente das coleções não é possível substituir um único elemento da tupla como apenas a chave ou o valor. É necessário atualizar todo o campo.


==== User-Defined Types

O user-defined Types, ou apenas UDT, é um tipo de dados criado pelo usuário. Esse tipo é criado a partir de um keyspace e segue o mesmo princípio de uma família de colunas, ou seja, será possível criar, alterar e dropar um UDT.

[source,sql]
----
create_type_statement ::=  CREATE TYPE [ IF NOT EXISTS ] udt_name
                               '(' field_definition ( ',' field_definition )* ')'
field_definition      ::=  identifier cql_type
----

Assim, como o tipo nativo, para ser utilizado é necessário defini-lo dentro de uma família de coluna. Por exemplo, para informação de um usuário da biblioteca é necessário o endereço, e nesse endereço terá o país e a cidade.

[source,sql]
----
CREATE TYPE IF NOT EXISTS library.name (
    first_name text,
    last_name text,
);
CREATE TABLE IF NOT EXISTS library.user (
    id text,
    name name,
    PRIMARY KEY (id)
);
INSERT INTO library.user (id, name) values ('otaviojava', {first_name: 'Otavio', last_name: 'Santana'});
INSERT INTO library.user (id, name) values ('poliana', {first_name: 'Poliana', last_name: 'Santana'});
cqlsh> SELECT * FROM library.user;

 id         | name
------------+-----------------------------------------------
    poliana | {first_name: 'Poliana', last_name: 'Santana'}
 otaviojava |  {first_name: 'Otavio', last_name: 'Santana'}
----

Por exemplo, dado o tipo nome, será adicionado o campo nome do meio.


[source,sql]
----
ALTER TYPE library.name ADD middle_name text;
cqlsh> SELECT * FROM library.user;

 id         | name
------------+------------------------------------------------------------------
    poliana | {first_name: 'Poliana', last_name: 'Santana', middle_name: null}
 otaviojava |  {first_name: 'Otavio', last_name: 'Santana', middle_name: null}

INSERT INTO library.user (id, name) values ('otaviojava', {first_name: 'Otavio', last_name: 'Santana', middle_name: 'Gonçalves'});
INSERT INTO library.user (id, name) values ('poliana', {first_name: 'Poliana', last_name: 'Santana', middle_name: 'Santos'});

cqlsh> SELECT * FROM library.user;
 id         | name
------------+------------------------------------------------------------------------
    poliana |   {first_name: 'Poliana', last_name: 'Santana', middle_name: 'Santos'}
 otaviojava | {first_name: 'Otavio', last_name: 'Santana', middle_name: 'Gonçalves'}
----

Também é possível remover remover o UDT como `DROP UDT`.

[source,sql]
----
drop_type_statement ::=  DROP TYPE [ IF EXISTS ] udt_name
----

Por exemplo, ao remover o campo nome da família de colunas:

[source,sql]
----
ALTER COLUMNFAMILY library.user DROP name;
cqlsh> SELECT * FROM library.user;
 id
------------
    poliana
 otaviojava

DROP TYPE IF EXISTS library.name;
----

Também é possível criar uma coleção de UDTs, para isso é necessário utilizar o keyword `frozen`, vale salientar que o UDT tem o seu funcionamento semelhante de uma tupla, ou seja, não é possível  alterar um único elemento.

[source,sql]
----
DROP TABLE IF EXISTS library.user;
DROP TABLE IF EXISTS library.user;
CREATE TYPE IF NOT EXISTS library.phone (
    country_code int,
    number text,
);
CREATE TABLE IF NOT EXISTS library.user (
    id text,
    phones set<frozen<phone>>,
    PRIMARY KEY (id)
);
----

=== Manipulando informação

Nesse tópico abordaremos a manipulação de dados, ou seja, será possível utilizar o famoso CRUD, ou seja, criar, recuperar, atualizar, deletar as informações.

==== Select

O `SELECT` é o tipo de comando utilizado para recuperar as informações dos dados.

[source,sql]
----
select_statement ::=  SELECT [ JSON | DISTINCT ] ( select_clause | '*' )
                      FROM table_name
                      [ WHERE where_clause ]
                      [ GROUP BY group_by_clause ]
                      [ ORDER BY ordering_clause ]
                      [ PER PARTITION LIMIT (integer | bind_marker) ]
                      [ LIMIT (integer | bind_marker) ]
                      [ ALLOW FILTERING ]
select_clause    ::=  selector [ AS identifier ] ( ',' selector [ AS identifier ] )
selector         ::=  column_name
                      | term
                      | CAST '(' selector AS cql_type ')'
                      | function_name '(' [ selector ( ',' selector )* ] ')'
                      | COUNT '(' '*' ')'
where_clause     ::=  relation ( AND relation )*
relation         ::=  column_name operator term
                      '(' column_name ( ',' column_name )* ')' operator tuple_literal
                      TOKEN '(' column_name ( ',' column_name )* ')' operator term
operator         ::=  '=' | '<' | '>' | '<=' | '>=' | '!=' | IN | CONTAINS | CONTAINS KEY
group_by_clause  ::=  column_name ( ',' column_name )*
ordering_clause  ::=  column_name [ ASC | DESC ] ( ',' column_name [ ASC | DESC ] )*
----

Por exemplo, na livraria será adicionado uma família de colunas do tipo revista que terá a lista de artigos e o ano do post.


[source,sql]
----
DROP COLUMNFAMILY IF EXISTS library.magazine;
CREATE COLUMNFAMILY IF NOT EXISTS library.magazine (
    id text,
    posted_at timestamp,
    articles set<text>,
    pages int,
    PRIMARY KEY (id, posted_at)
);

INSERT INTO library.magazine (id, posted_at, articles, pages) values ('Java Magazine', '2018-01-01',{'Jakarta EE', 'Java 8', 'Cassandra'}, 140);
INSERT INTO library.magazine (id, posted_at, articles, pages) values ('Java Magazine', '2017-01-01',{'Java EE 8', 'Java 7', 'NoSQL'}, 100);
----

É possível recuperar todos campos de uma linha, para isso, basta utilizar o `*` asterisco e também busca campos específicos separando o nome do campo por virgula.

[source,sql]
----
cqlsh> SELECT * FROM library.magazine;

 id            | posted_at                       | articles                              | pages
---------------+---------------------------------+---------------------------------------+-------
 Java Magazine | 2017-01-01 00:00:00.000000+0000 |      {'Java 7', 'Java EE 8', 'NoSQL'} |   100
 Java Magazine | 2018-01-01 00:00:00.000000+0000 | {'Cassandra', 'Jakarta EE', 'Java 8'} |   140


cqlsh> SELECT id, posted_at FROM library.magazine;

 id            | posted_at
---------------+---------------------------------
 Java Magazine | 2017-01-01 00:00:00.000000+0000
 Java Magazine | 2018-01-01 00:00:00.000000+0000

cqlsh> SELECT count(*) FROM library.magazine;

 count
-------
     2

----

Também é possível realizar a operação o agrupamento com a keyword `GROUP BY`, porém, para utilizar esse recurso é necessário que o campo alvo seja uma chave primária.

[source,sql]
----
cqlsh> SELECT id, max(pages) FROM library.magazine GROUP BY id;

 id            | system.max(pages)
---------------+-------------------
 Java Magazine |               140

cqlsh> SELECT id, min(pages) FROM library.magazine GROUP BY id;

  id            | system.min(pages)
 ---------------+-------------------
  Java Magazine |               100


cqlsh> SELECT id, sum(pages) FROM library.magazine GROUP BY id;

 id            | system.sum(pages)
---------------+-------------------
 Java Magazine |               240

----

Também é possível limitar o número de elementos numa query, para isso, se utiliza o `LIMIT`.


[source,sql]
----
cqlsh> SELECT * FROM library.magazine LIMIT 1;

 id            | posted_at                       | articles                         | pages
---------------+---------------------------------+----------------------------------+-------
 Java Magazine | 2017-01-01 00:00:00.000000+0000 | {'Java 7', 'Java EE 8', 'NoSQL'} |   100
----


O recurso de ordenação o resultado é definido pela palavra-chave `ORDER BY`, esse recurso é possível apenas com as chaves primárias do tipo clustering order.

[source,sql]
----
 SELECT * FROM library.magazine where id = 'Java Magazine' ORDER BY posted_at DESC;
 id            | posted_at                       | articles                              | pages
---------------+---------------------------------+---------------------------------------+-------
 Java Magazine | 2018-01-01 00:00:00.000000+0000 | {'Cassandra', 'Jakarta EE', 'Java 8'} |   140
 Java Magazine | 2017-01-01 00:00:00.000000+0000 |      {'Java 7', 'Java EE 8', 'NoSQL'} |   100


 SELECT * FROM library.magazine where id = 'Java Magazine' ORDER BY posted_at ASC;

  id            | posted_at                       | articles                              | pages
 ---------------+---------------------------------+---------------------------------------+-------
  Java Magazine | 2017-01-01 00:00:00.000000+0000 |      {'Java 7', 'Java EE 8', 'NoSQL'} |   100
  Java Magazine | 2018-01-01 00:00:00.000000+0000 | {'Cassandra', 'Jakarta EE', 'Java 8'} |   140


----

Dentro do select também é possível recuperar o valor no formato *JSON*

[source,sql]
----
cqlsh> SELECT JSON * FROM library.magazine;

 [json]
-----------------------------------------------------------------------------------------------------------------------------------
      {"id": "Java Magazine", "posted_at": "2017-01-01 00:00:00.000Z", "articles": ["Java 7", "Java EE 8", "NoSQL"], "pages": 100}
 {"id": "Java Magazine", "posted_at": "2018-01-01 00:00:00.000Z", "articles": ["Cassandra", "Jakarta EE", "Java 8"], "pages": 140}

cqlsh> SELECT JSON id, pages FROM library.magazine;

 [json]
---------------------------------------
 {"id": "Java Magazine", "pages": 100}
 {"id": "Java Magazine", "pages": 140}

----


TIP: Como já foi explicado, as operações de buscas que necessitam por condições, onde necessita a cláusula `WHERE`, só serão possíveis ou a partir da chave primário, partition key, ou pela criação de um índice. Existe a exceção que é o uso do recurso do `ALLOW FILTERING`, porém, utilizar esse recurso demanda um altíssimo impacto de performance.

==== Insert

Dentro da cláusula `INSERT` é possível inserir uma linha dentro da família de coluna.

[source,sql]
----
insert_statement ::=  INSERT INTO table_name ( names_values | json_clause )
                      [ IF NOT EXISTS ]
                      [ USING update_parameter ( AND update_parameter )* ]
names_values     ::=  names VALUES tuple_literal
json_clause      ::=  JSON string [ DEFAULT ( NULL | UNSET ) ]
names            ::=  '(' column_name ( ',' column_name )* ')'
----

Para inserir os dados utilizando a cláusula `INSERT` é possível utilizando tanto  de uma forma bem semelhante ao SQL e também como JSON. Por exemplo, utilizando a família de coluna magazine anteior.

[source,sql]
----
INSERT INTO library.magazine (id, posted_at, articles, pages) values ('Java Magazine', '2017-01-01',{'Java EE 8', 'Java 7', 'NoSQL'}, 100);
INSERT INTO library.magazine JSON '{"id": "Java Magazine", "posted_at": "2017-01-01", "pages": 10, "articles": ["Java EE 8", "Java 7", "NoSQL"]}';
----

Um ponto importante é a chave, assim como no relacional, é obrigatório, vale lembrar que é a partir dela que é definido onde a informação será enviada através do cluster.


[source,sql]
----
INSERT INTO library.magazine JSON '{"posted_at": "2017-01-01", "pages": 10, "articles": ["Java EE 8", "Java 7", "NoSQL"]}';
InvalidRequest: Error from server: code=2200 [Invalid query] message="Invalid null value in condition for column id"
INSERT INTO library.magazine JSON '{"id": "Java Magazine", "posted_at": "2017-01-01", "pages": 10}';
INSERT INTO library.magazine JSON '{"id": "Java Magazine", "posted_at": "2017-01-01"}';
----

Um ponto importante é que além da verificação da chave primária, não existe nenhuma outra validação, ou seja, é possível diferentes valores com a mesma chave sem nenhum problema. Basicamente, se a chave não existir ela será criada, do contrário, ela será sobrescrita.

[source,sql]
----
INSERT INTO library.magazine JSON '{"id": "Java Magazine", "posted_at": "2017-01-01", "pages": 112}';
INSERT INTO library.magazine JSON '{"id": "Java Magazine", "posted_at": "2017-01-01", "pages": 121}';
INSERT INTO library.magazine JSON '{"id": "Java Magazine", "posted_at": "2017-01-01", "pages": 90}';
----

Também é possível definir uma inserção com TTL, que significa o tempo de vida de uma linha em segundos.

[source,sql]
----
TRUNCATE library.magazine ;
INSERT INTO library.magazine (id, posted_at) values ('Java Magazine', '2017-01-01') USING TTL 10;
cqlsh> SELECT * FROM library.magazine WHERE id = 'Java Magazine';

 id            | posted_at                       | articles | pages
---------------+---------------------------------+----------+-------
 Java Magazine | 2017-01-01 00:00:00.000000+0000 |     null |  null
//wait 10 seconds
cqlsh> SELECT * FROM library.magazine WHERE id = 'Java Magazine';
 id | posted_at | articles | pages
----+-----------+----------+-------

(0 rows)
----

==== Update

Para atualizar existe a cláusula `UPDATE`. De uma maneira geral, o update para o Cassandra nada mais é que um `INSERT` com o `WHERE`. Assim, como no `INSERT` caso a informação exista será atualizada, do contrário, será sobrescrita.

Por exemplo, dado uma simples família de colunas de bibliotecário.

.Criação da família de coluna bibliotecário, como é possível ver é inserido um bibliotecário mesmo utilizando a cláusula `UPDATE`.
[source,sql]
----
DROP COLUMNFAMILY IF EXISTS library.librarian;

CREATE COLUMNFAMILY IF NOT EXISTS library.librarian (
    id text,
    name text,
    PRIMARY KEY (id)
);

UPDATE library.librarian set name = 'Ivar' where id = 'ivar';
cqlsh> SELECT * FROM library.librarian;

 id   | name
------+------
 ivar | Ivar

(1 rows)

----

Também é possível realizar atualizar o TTL do registro.

[source,sql]
----
UPDATE library.librarian USING TTL 12 set name = 'Daniel' where id = 'daniel';
cqlsh> SELECT * FROM library.librarian where id = 'daniel';
 id     | name
--------+--------
 daniel | Daniel
//wait 10 seconds
cqlsh> SELECT * FROM library.librarian where id = 'daniel';

 id | name
----+------
----
==== Delete

Com a cláusula `DELETE` é possível remover registros dentro do Cassandra é possível remover uma coluna ou todo o registro, sendo que para qualquer operação é necessário a chave primária, a partition key.


[source,sql]
----
DROP COLUMNFAMILY IF EXISTS library.librarian;

CREATE COLUMNFAMILY IF NOT EXISTS library.librarian (
    id text,
    name text,
    PRIMARY KEY (id)
);

INSERT INTO library.librarian JSON '{"name": "Ivar", "id": "ivar"}';
INSERT INTO library.librarian JSON '{"name": "Daniel Dias", "id": "dani"}';
INSERT INTO library.librarian JSON '{"name": "Gabriela Santana", "id": "gabriela"}';

cqlsh> SELECT * FROM library.librarian;

 id       | name
----------+------------------
     dani |      Daniel Dias
 gabriela | Gabriela Santana
     ivar |             Ivar

(3 rows)

DELETE FROM library.librarian where id = 'dani';
cqlsh> SELECT * FROM library.librarian;
 id       | name
----------+------------------
 gabriela | Gabriela Santana
     ivar |             Ivar

(2 rows)
DELETE name FROM library.librarian where id = 'ivar';
cqlsh> SELECT * FROM library.librarian;
 id       | name
----------+------------------
 gabriela | Gabriela Santana
     ivar |             null

(2 rows)

----

==== Batch

É partir do `Batch` é possível realizar múltiplas operações de alteração (insert, update e delete). As operações dentro de um batch tem com o objetivo de realizar diversas operações de maneira atômica, ou seja, a operação acontece ou não.


É importante salientar que:

* Os `BATCH` podem conter apenas insert, update e delete
* Os batches não tem total suporte a transação como os bancos relacionais
* Todas as operações pertencem a partition key para garantir isolamento
* Por padrão as operações dentro do batch serão atômicas, assim as operações serão eventualmente completas ou nenhuma irá.
* Existe um grande trade-off no uso do `BATCH` por um lado pode economizar rede, na comunicação entre nó coordenador e os outros nós, para as operações também pode sobreutilizar um nó para diversas operações, daí importância de saber usar esse recurso com pacimônia.


[source,sql]
----
batch_statement        ::=  BEGIN [ UNLOGGED | COUNTER ] BATCH
                            [ USING update_parameter ( AND update_parameter )* ]
                            modification_statement ( ';' modification_statement )*
                            APPLY BATCH
modification_statement ::=  insert_statement | update_statement | delete_statement
----

Por exemplo, realizando operações dentro da família de coluna dos bibliotecários.

[source,sql]
----
BEGIN BATCH
INSERT INTO library.librarian JSON '{"name": "Ivar", "id": "ivar"}';
INSERT INTO library.librarian JSON '{"name": "Daniel Dias", "id": "dani"}';
INSERT INTO library.librarian JSON '{"name": "Gabriela Santana", "id": "gabriela"}';
DELETE FROM library.librarian where id = 'dani';
APPLY BATCH;

cqlsh> SELECT * FROM library.librarian;

 id       | name
----------+------------------
 gabriela | Gabriela Santana
     ivar |             Ivar

(2 rows)

----

=== View materilizada

A desanimalização é a melhor amiga dos bancos de dados do tipo não relacionais, com o Cassandra isso não é uma exceção. Um dos recursos que podem facilitar nessa modelagem é a criação de view materializadas. Esse recurso serve como uma aliada para a desnormalização ao mesmo tempo que garante a consistência de uma família de coluna. Um ponto importante é que a view materializada não pode sofrer nenhuma alteração.


[source,sql]
----
create_materialized_view_statement ::=  CREATE MATERIALIZED VIEW [ IF NOT EXISTS ] view_name AS
                                            select_statement
                                            PRIMARY KEY '(' primary_key ')'
                                            WITH table_options
----

Por exemplo, considerando novamente o caso do livro. Considerando que temos o código o ISBN, International Standard Book Number que funciona como um registro único do livro no mundo, e tal código é que os funcionários utilizam frequentemente para emprestar ou não um livro dentro da biblioteca. Assim, criaremos a família de coluna da seguinte forma:

[source,sql]
----
DROP COLUMNFAMILY IF EXISTS library.book;
CREATE COLUMNFAMILY IF NOT EXISTS library.book (
    isbn bigint,
    name text,
    author text,
    PRIMARY KEY (isbn)
);

INSERT INTO library.book JSON '{"isbn": 1, "name": "Clean Code", "author": "Robert Cecil Martin"}';
INSERT INTO library.book JSON '{"isbn": 2, "name": "Effective Java", "author": "Joshua Bloch"}';
INSERT INTO library.book JSON '{"isbn": 3, "name": "The Pragmatic Programmer", "author": "Andy Hunt"}';
----


Pronto, agora é possível realizar buscas de maneira tranquila a partir do ISBN. Porém, considerando que o ISBN é feito de maneira incremental, gostaríamos de retornar os livros mais recentes da biblioteca, para isso, será criado uma view materializada do qual só serão aceitos ISBN maiores que 3. Assim:

[source,sql]
----
CREATE MATERIALIZED VIEW IF NOT EXISTS library.recent_book AS
    SELECT * FROM library.book
    WHERE isbn > 3 AND name IS NOT NULL
    PRIMARY KEY (isbn, name);

Warnings : Materialized views are experimental and are not recommended for production use.
----

Pronto, view materializada criada, agora é possível utilizar essa view para buscar apenas os livros mais recentes.


[source,sql]
----
cqlsh> SELECT * FROM library.recent_book;

 isbn | name | author
------+------+--------

INSERT INTO library.book JSON '{"isbn": 4, "name": "Java EE 8 Cookbook", "author": "Elder Moraes"}';
INSERT INTO library.book JSON '{"isbn": 5, "name": "Best Developer Job Ever!", "author": "Bruno Souza"}';

cqlsh> SELECT * FROM library.recent_book;
 isbn | name                     | author
------+--------------------------+--------------
    4 |       Java EE 8 Cookbook | Elder Moraes
    5 | Best Developer Job Ever! |  Bruno Souza

----

Também é possível realizar a alteração ou remover a view materializada.


[source,sql]
----
DROP MATERIALIZED VIEW library.recent_book;
----


WARNINGS: Até o momento o recurso de view materializada se encontra em carater experimental

=== Segurança


Um dos pontos que o Cassandra tem suporte é o recurso de segurança. Assim, é possível definir permissão, criar usuário, cria regras, remover permissão dentre outros. O primeiro ponto para utilizar tais recursos é habilitar o recurso de segurança pelo Cassandra. Para isso, é necessário realizar uma mudança dentro do cassandra.yaml dentro da pasta `conf` na linha `authenticator: AllowAllAuthenticator` realizar a mudança para `authenticator: PasswordAuthenticator`.
Para habilitar o gerenciamento de permissão do Cassandra também é necessário alterar a linha `authorizer: AllowAllAuthorizer` para `authorizer: CassandraAuthorizer`.


Caso esteja utilizando docker a solução seria mapear o pasta de configuração já definido. Assim:

[source,sql]
----
docker run --name some-cassandra -p 9042:9042 -v /my/own/datadir:/var/lib/cassandra -v  /path/to/config/cassandra.yaml:/etc/cassandra/cassandra.yaml -d cassandra
//sample
docker run --name some-cassandra -p 9042:9042 -v /home/otaviojava/data:/var/lib/cassandra -v /home/otaviojava/config:/etc/cassandra -d cassandra
----



Feita a habilitação o primeiro passo é acessar o cliente Cassandra novamente, porém, dessa vez teremos uma mensagem de erro:

[source,sql]
----
./cqlsh
Connection error: ('Unable to connect to any servers', {'127.0.0.1': AuthenticationFailed('Remote end requires authentication.',)})
----

Esse erro acontece porque é necessário ter autorização de acesso, assim, é o superusuário default é `cassandra` e a senha `cassandra`.

[source,sql]
----
./cqlsh -u cassandra -p cassandra
Connected to Test Cluster at 127.0.0.1:9042.
[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]
Use HELP for help.
cassandra@cqlsh>
----

Para docker o acesso é semelhante, basta procurar o ID do container depois adicionar os parâmetros de usuário e senha.

[source,sql]
----
 docker exec -it 66e5f38a3815 cqlsh -u cassandra -p cassandra
----

Toda a criação foi definida a partir dos ROLES, por exemplo, é possível criar alguns usuários.

.Os usuários ada, alice criados.
[source,sql]
----
CREATE ROLE ada;
CREATE ROLE alice WITH PASSWORD = 'alice' AND LOGIN = true;
cqlsh> LIST ROLES;
 role      | super | login | options
-----------+-------+-------+---------
       ada | False | False |        {}
     alice | False |  True |        {}
 cassandr
----

Agora é possível, realizar o login com o usuário alice.

[source,sql]
----
./cqlsh -u alice -p alice
Connected to Test Cluster at 127.0.0.1:9042.
[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]
Use HELP for help.
alice@cqlsh>
----

Uma vez que o usuário alice não tem permissão de super usuário, não será possível remover campos sensíveis do sistema.

[source,sql]
----
alice@cqlsh> DROP KEYSPACE IF EXISTS system_auth;
Unauthorized: Error from server: code=2100 [Unauthorized] message="Cannot DROP <keyspace system_auth>"
----

Também é possível alterar a informação de usuário, por exemplo, para fazer com que o usuário alice tenha permissão de superusuário.

[source,sql]
----
ALTER ROLE alice WITH SUPERUSER = true;

cassandra@cqlsh> LIST ROLES;
 role      | super | login | options
-----------+-------+-------+---------
       ada | False | False |        {}
     alice |  True |  True |        {}
 cassandra |  True |  True |        {}

----

Também é possível remover o usuário:
[source,sql]
----
DROP ROLE ada;
cassandra@cqlsh> LIST ROLES;
 role      | super | login | options
-----------+-------+-------+---------
     alice |  True |  True |        {}
 cassandra |  True |  True |        {}

(2 rows)

----


Com os usuários criados, agora é possível, por exemplo, criar regras e definir as permissões para cada estrutura dentro do banco de dados. As opções disponíveis são:

* CREATE
* ALTER
* DROP
* SELECT
* MODIFY
* AUTHORIZE
* DESCRIBE
* EXECUTE

[source,sql]
----
grant_permission_statement ::=  GRANT permissions ON resource TO role_name
permissions                ::=  ALL [ PERMISSIONS ] | permission [ PERMISSION ]
permission                 ::=  CREATE | ALTER | DROP | SELECT | MODIFY | AUTHORIZE | DESCRIBE | EXECUTE
resource                   ::=  ALL KEYSPACES
                               | KEYSPACE keyspace_name
                               | [ TABLE ] table_name
                               | ALL ROLES
                               | ROLE role_name
                               | ALL FUNCTIONS [ IN KEYSPACE keyspace_name ]
                               | FUNCTION function_name '(' [ cql_type ( ',' cql_type )* ] ')'
                               | ALL MBEANS
                               | ( MBEAN | MBEANS ) string
----


Para elucidar o nosso, faremos um exemplo e mais uma vez utilizando como referência o nosso sistema de livraria. Inicialmente, teremos os seguintes usuários:

* A regra de `user` que apenas pode ler dentro do keyspace biblioteca
* A regra de `librarian` que pode realizar alterações no keyspace da biblioteca
* A regra de `manager` que pode criar tabelas dentro do keyspace da biblioteca

Com base nessas regras criaremos:

* ada como usuário
* mike como bibliotecário
* jonh como manager


[source,sql]
----
CREATE KEYSPACE IF NOT EXISTS library  WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
//create the role user
CREATE ROLE IF NOT EXISTS user;
GRANT SELECT ON KEYSPACE library TO user;
//create user ada
CREATE ROLE ada WITH PASSWORD = 'ada' AND LOGIN = true;
GRANT user TO ada;
//create the role librarian
CREATE ROLE IF NOT EXISTS librarian;
GRANT MODIFY ON KEYSPACE library TO librarian;
GRANT SELECT ON KEYSPACE library TO librarian;
//create mike
CREATE ROLE mike WITH PASSWORD = 'mike' AND LOGIN = true;
GRANT librarian TO mike;
//create manager
CREATE ROLE IF NOT EXISTS manager;
GRANT ALTER ON KEYSPACE library TO manager;
GRANT CREATE ON KEYSPACE library TO manager;
//create jonh
CREATE ROLE jonh WITH PASSWORD = 'jonh' AND LOGIN = true;
GRANT manager TO jonh;
----

Pronto com todos os usuários criados o primeiro passo é explorar um pouco da segurança dentro do segurança.


[source,sql]
----
./cqlsh -u ada -p ada

CREATE COLUMNFAMILY IF NOT EXISTS library.magazine (
    id text,
    pages int,
    PRIMARY KEY (id)
);

Unauthorized: Error from server: code=2100 [Unauthorized] message="User ada has no CREATE permission on <keyspace library> or any of its parents"

./cqlsh -u jonh -p jonh

CREATE COLUMNFAMILY IF NOT EXISTS library.magazine (
   id text,
    pages int,
    PRIMARY KEY (id)
);

 ./cqlsh -u mike -p mike

INSERT INTO library.magazine JSON '{"id": "new magazine", "pages": 10}';
SELECT * FROM library.magazine;

 id           | pages
--------------+-------
 new magazine |    10

(1 rows)

./cqlsh -u ada -p ada

SELECT * FROM library.magazine ;

 id           | pages
--------------+-------
 new magazine |    10

INSERT INTO library.magazine JSON '{"id": "new magazine", "pages": 10}';
Unauthorized: Error from server: code=2100 [Unauthorized] message="User ada has no MODIFY permission on <table library.magazine> or any of its parents"

----